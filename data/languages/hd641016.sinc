define endian=big;
define alignment=1;

define space ram type=ram_space size=4 wordsize=1 default;
define space register type=register_space size=4;

define register offset=0 size=4
[R0 R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 R11 R12 R13 R14 R15];
define register offset=0x100 size=4 [PC ssp bsp ebr rbr ibr cbnr sr ccr bmr gbnr vbnr];

# 8 â€“ token size
# field op includes bits 0 to 7
define token opcode(8)
	op = (0,7)
	sz = (0,1)
	op_2_to_7 = (2,7)

    ead = (0,6)
    Rn = (0,3)
    ea_2_to_6 = (2,6)
    ea_4_to_6 = (4,6)
    ea_6_to_7 = (6,7)
    ea_6 = (6,6)
    ea_Sd = (4,5)
    ea_si = (0,1)
    ea_a = (7,7)
;

define token data8 (8)
    cc      = (0,3)
    cr_code = (0,7)
    imm4    = (0,3)
    imm8    = (0,7)
    simm8   = (0,7) signed
    ea8     = (0,7)

    Rnx     = (0,3)
    Rny     = (4,7)

    Rnd     = (0,3)
    Rns     = (4,7)
;

define token reglist(16)
    reglist_r0 = (0,0)
    reglist_r1 = (1,1)
    reglist_r2 = (2,2)
    reglist_r3 = (3,3)
    reglist_r4 = (4,4)
    reglist_r5 = (5,5)
    reglist_r6 = (6,6)
    reglist_r7 = (7,7)
    reglist_r8 = (8,8)
    reglist_r9 = (9,9)
    reglist_r10 = (10,10)
    reglist_r11 = (11,11)
    reglist_r12 = (12,12)
    reglist_r13 = (13,13)
    reglist_r14 = (14,14)
    reglist_r15 = (15,15)
;

define token data16 (16)
    imm16   = (0,15)
    simm16  = (0,15) signed
;

define token data32 (32)
	imm32   = (0,31)
    simm32  = (0,31) signed
;

attach variables [ Rn Rnd Rns Rnx Rny ] [
	R0  R1  R2  R3  R4  R5  R6  R7
	R8  R9 R10 R11 R12  R13  R14  R15
];

disp8: rel is simm8 [ rel = inst_next + simm8; ] {
    export *:4 rel;
} 
disp16: rel is simm16 [ rel = inst_next + simm16; ] {
    export *:4 rel;
} 
disp32: rel is simm32 [ rel = inst_next + simm32; ] {
    export *:4 rel;
}

REGLIST_R0:             R0    is              reglist_r0=1 & R0 { }
REGLIST_R0:                   is              reglist_r0=0 { }
REGLIST_R1:  REGLIST_R0 R1    is REGLIST_R0 & reglist_r1=1 & R1 { }
REGLIST_R1:  REGLIST_R0       is REGLIST_R0 & reglist_r1=0 { }
REGLIST_R2:  REGLIST_R1 R2    is REGLIST_R1 & reglist_r2=1 & R2 { }
REGLIST_R2:  REGLIST_R1       is REGLIST_R1 & reglist_r2=0 { }
REGLIST_R3:  REGLIST_R2 R3    is REGLIST_R2 & reglist_r3=1 & R3 { }
REGLIST_R3:  REGLIST_R2       is REGLIST_R2 & reglist_r3=0 { }
REGLIST_R4:  REGLIST_R3 R4    is REGLIST_R3 & reglist_r4=1 & R4 { }
REGLIST_R4:  REGLIST_R3       is REGLIST_R3 & reglist_r4=0 { }
REGLIST_R5:  REGLIST_R4 R5    is REGLIST_R4 & reglist_r5=1 & R5 { }
REGLIST_R5:  REGLIST_R4       is REGLIST_R4 & reglist_r5=0 { }
REGLIST_R6:  REGLIST_R5 R6    is REGLIST_R5 & reglist_r6=1 & R6 { }
REGLIST_R6:  REGLIST_R5       is REGLIST_R5 & reglist_r6=0 { }
REGLIST_R7:  REGLIST_R6 R7    is REGLIST_R6 & reglist_r7=1 & R7 { }
REGLIST_R7:  REGLIST_R6       is REGLIST_R6 & reglist_r7=0 { }
REGLIST_R8:  REGLIST_R7 R8    is REGLIST_R7 & reglist_r8=1 & R8 { }
REGLIST_R8:  REGLIST_R7       is REGLIST_R7 & reglist_r8=0 { }
REGLIST_R9:  REGLIST_R8 R9    is REGLIST_R8 & reglist_r9=1 & R9 { }
REGLIST_R9:  REGLIST_R8       is REGLIST_R8 & reglist_r9=0 { }
REGLIST_R10: REGLIST_R9 R10   is REGLIST_R9 & reglist_r10=1 & R10 { }
REGLIST_R10: REGLIST_R9       is REGLIST_R9 & reglist_r10=0 { }
REGLIST_R11: REGLIST_R10 R11  is REGLIST_R10 & reglist_r11=1 & R11 { }
REGLIST_R11: REGLIST_R10      is REGLIST_R10 & reglist_r11=0 { }
REGLIST_R12: REGLIST_R11 R12  is REGLIST_R11 & reglist_r12=1 & R12 { }
REGLIST_R12: REGLIST_R11      is REGLIST_R11 & reglist_r12=0 { }
REGLIST_R13: REGLIST_R12 R13  is REGLIST_R12 & reglist_r13=1 & R13 { }
REGLIST_R13: REGLIST_R12      is REGLIST_R12 & reglist_r13=0 { }
REGLIST_R14: REGLIST_R13 R14  is REGLIST_R13 & reglist_r14=1 & R14 { }
REGLIST_R14: REGLIST_R13      is REGLIST_R13 & reglist_r14=0 { }
REGLIST_R15: REGLIST_R14 R15  is REGLIST_R14 & reglist_r15=1 & R15 { }
REGLIST_R15: REGLIST_R14      is REGLIST_R14 & reglist_r15=0 { }
REGLIST: REGLIST_R15          is REGLIST_R15 { }

CR: "CCR"   is cr_code=0b00100000 { }
CR: "VBNR"  is cr_code=0b00000001 { }
CR: "CBNR"  is cr_code=0b01000000 { }
CR: "BSP"   is cr_code=0b01000001 { }
CR: "BMR"   is cr_code=0b10000000 { }
CR: "GBNR"  is cr_code=0b10000001 { }
CR: "SR"    is cr_code=0b10100000 { }
CR: "EBR"   is cr_code=0b11000000 { }
CR: "RBR"   is cr_code=0b11000001 { }
CR: "USP"   is cr_code=0b11000010 { }
CR: "IBR"   is cr_code=0b11000011 { }

CC: "CC"    is cc=0b0100 { }
CC: "CS"    is cc=0b0101 { }
CC: "NE"    is cc=0b0110 { }
CC: "EQ"    is cc=0b0111 { }
CC: "GE"    is cc=0b1100 { }
CC: "LT"    is cc=0b1101 { }
CC: "GT"    is cc=0b1110 { }
CC: "LE"    is cc=0b1111 { }
CC: "HI"    is cc=0b0010 { }
CC: "LS"    is cc=0b0011 { }
CC: "PL"    is cc=0b1010 { }
CC: "MI"    is cc=0b1011 { }
CC: "VC"    is cc=0b1000 { }
CC: "VS"    is cc=0b1001 { }
CC: "T"     is cc=0b0000 { }
CC: "F"     is cc=0b0001 { }

Sz: ".B" is sz=0b00 { }
Sz: ".W" is sz=0b01 { }
Sz: ".L" is sz=0b10 { }

ea_Si: ".B" is ea_si=0b01 { }
ea_Si: ".W" is ea_si=0b10 { }
ea_Si: ".L" is ea_si=0b11 { }

with EA: {
    # 1. Register direct
    : Rn is Rn & ea_4_to_6=0b100 { }

    # 2. Register indirect
    : "@"Rn is Rn & ea_6=0b0 & ea_Sd=0b00 { }
    : "@("imm8, Rn) is Rn & ea_6=0b0 & ea_Sd=0b01; imm8 { }
    : "@("imm16, Rn) is Rn & ea_6=0b0 & ea_Sd=0b10; imm16 { }
    : "@("imm32, Rn) is Rn & ea_6=0b0 & ea_Sd=0b11; imm32 { }

    # 3. Register indirect auto-increment
    : "@"Rn"+" is Rn & ea_4_to_6=0b101 { }

    # 4. Register indirect auto-decrement
    : "@-"Rn is Rn & ea_4_to_6=0b110 { }

    # 5. Immediate
    : imm8^ea_Si is ea_2_to_6=0b11100 & ea_si=0b01 & ea_Si; imm8 { }
    : imm16^ea_Si is ea_2_to_6=0b11100 & ea_si=0b10 & ea_Si; imm16 { }
    : imm32^ea_Si is ea_2_to_6=0b11100 & ea_si=0b11 & ea_Si; imm32 { }

    # 6. Absolute Address
    : "@" imm8  is ea_2_to_6=0b11101 & ea_si=0b01; imm8 { }
    : "@" imm16 is ea_2_to_6=0b11101 & ea_si=0b10; imm16 { }
    : "@" imm32 is ea_2_to_6=0b11101 & ea_si=0b11; imm32 { }

    # 10. Program counter relative
    : @PC           is PC & (ead=0b1111101); (ea_6_to_7=0b10 & ea_Sd=0b00) { }
    : @(imm8, PC)   is PC & (ead=0b1111101); (ea_6_to_7=0b10 & ea_Sd=0b01); imm8 { }
    : @(imm16, PC)  is PC & (ead=0b1111101); (ea_6_to_7=0b10 & ea_Sd=0b10); imm16 { }
    : @(imm32, PC)  is PC & (ead=0b1111101); (ea_6_to_7=0b10 & ea_Sd=0b11); imm32 { }
}

EAs: EA is EA { export EA; }
EAd: EA is EA { export EA; }

# ADD:G (Add Binary)
:ADD^Sz EAs, EAd is op_2_to_7=0b000000 & Sz; (ea_a=0 ... & EAs); EAd unimpl
:ADD^Sz EAs, R0 is op_2_to_7=0b000000 & Sz & R0; (ea_a=1 ... & EAs) unimpl


:SUB_G  is (op=0x04 | op=0x05 | op=0x06) unimpl

# CMG:G (Compare)
:CMP^Sz EAs, EAd is op_2_to_7=0b000010 & Sz; (ea_a=0 ... & EAs); EAd unimpl
:CMP^Sz EAs, R0 is op_2_to_7=0b000010 & Sz & R0; (ea_a=1 ... & EAs) unimpl

# MOV:G (Move Data from Source to Destination)
:MOV^Sz EAs, EAd is op_2_to_7=0b000011 & Sz; (ea_a=0 ... & EAs); EAd unimpl
:MOV^Sz EAs, R0 is op_2_to_7=0b000011 & Sz & R0; (ea_a=1 ... & EAs) unimpl

:ADD_Q  is (op=0x10 | op=0x11 | op=0x12) unimpl

# CLR (CLR)
:CLR^Sz EAd is op_2_to_7=0b000101 & Sz; EAd unimpl

:CMP_Q  is (op=0x18 | op=0x19 | op=0x1A) unimpl
:MOV":Q"^Sz simm8, EAd is (op_2_to_7=0b000111 & Sz); simm8; EAd unimpl

:ADD_R  is (op=0x20 | op=0x21 | op=0x22) unimpl
:SUB_R  is (op=0x24 | op=0x25 | op=0x26) unimpl
:CMP_R  is (op=0x28 | op=0x29 | op=0x2A) unimpl

# MOV:R (Move Register)
:MOV^Sz Rns, Rnd is (op_2_to_7=0b001011 & Sz); (Rns & Rnd) unimpl

:ADD_RQ is (op=0x30 | op=0x31 | op=0x32) unimpl
:SUB_RQ is (op=0x34 | op=0x35 | op=0x36) unimpl
:CMP_RQ is (op=0x38 | op=0x39 | op=0x3A) unimpl
:MOV_RQ is (op=0x3C | op=0x3D | op=0x3E) unimpl

:ADDS   is (op=0x40 | op=0x41 | op=0x42) unimpl
:SUBS   is (op=0x44 | op=0x45 | op=0x46) unimpl
:CMPS   is (op=0x48 | op=0x49 | op=0x4A) unimpl
:MOVS   is (op=0x4C | op=0x4D | op=0x4E) unimpl

:ADDX   is (op=0x50 | op=0x51 | op=0x52) unimpl
:SUBX   is (op=0x54 | op=0x55 | op=0x56) unimpl
:TST    is (op=0x58 | op=0x59 | op=0x5A) unimpl
:MOVF   is (op=0x5C | op=0x5D | op=0x5E) unimpl

:SFT    is (op=0x60 | op=0x61 | op=0x62 | op=0x64 | op=0x65 | op=0x66) unimpl
:BIT    is (op=0x67 | op=0x69 | op=0x6A | op=0x6C | op=0x6D | op=0x6E) unimpl

# TODO: determine size, parse ea, parse register list
:STM^Sz [REGLIST], EA    is op_2_to_7=0b011100 & Sz; EA; REGLIST {

}

# TODO: parse register list
:LDM^Sz EAs, [REGLIST]    is (op_2_to_7=0b011101 & Sz); EAs; REGLIST unimpl
:MOVTPE is (op=0x78 | op=0x79 | op=0x7A) unimpl
:MOVFPW is (op=0x7C | op=0x7D | op=0x7E) unimpl

:AND    is (op=0x80 | op=0x81 | op=0x82) unimpl
:XOR    is (op=0x84 | op=0x85 | op=0x86) unimpl
:OR     is (op=0x88 | op=0x89 | op=0x8A) unimpl
:NEG    is (op=0x8C | op=0x8D | op=0x8E) unimpl

:NOT    is (op=0x90 | op=0x91 | op=0x92) unimpl
:STRING is (op=0x94 | op=0x95 | op=0x96) unimpl
:BRA    is (op=0x98 | op=0x99 | op=0x9A) unimpl
:JMP    is (op=0x9B) unimpl
:NEGX   is (op=0x9C | op=0x9D | op=0x9E) unimpl

:BEQ    is (op=0xA0 | op=0xA1 | op=0xA2) unimpl
:DADD   is (op=0xA3) unimpl

# Bcc:G (Branch According to Condition Code)
:B^CC disp8  is (op_2_to_7=0b101001 & sz=0b00); cc & CC; disp8 unimpl
:B^CC disp16 is (op_2_to_7=0b101001 & sz=0b01); cc & CC; disp16 unimpl
:B^CC disp32 is (op_2_to_7=0b101001 & sz=0b10); cc & CC; disp32 unimpl

:DSUB   is (op=0xA7) unimpl
:BSR disp8  is (op_2_to_7=0b101010 & sz=0b00); disp8 unimpl
:BSR disp16 is (op_2_to_7=0b101010 & sz=0b01); disp16 unimpl
:BSR disp32 is (op_2_to_7=0b101010 & sz=0b10); disp32 unimpl
:JSR    is (op=0xAB) unimpl
:EXTU   is (op=0xAC | op=0xAD | op=0xAE) unimpl
:DNEG   is (op=0xAF) unimpl

:BNE disp8 is (op_2_to_7=0b101100 & sz=0b00); disp8 unimpl
:BNE disp16 is (op_2_to_7=0b101100 & sz=0b01); disp16 unimpl
:BNE disp32 is (op_2_to_7=0b101100 & sz=0b10); disp32 unimpl

# XCH (Exchange Registers)
:XCH Rnx, Rny is op=0b10110011; (Rnx & Rny) unimpl

:SCB    is (op=0xB4 | op=0xB5 | op=0xB6) unimpl
:SET    is (op=0xB7) unimpl
:RTD    is (op=0xB8 | op=0xB9 | op=0xBA) unimpl
:RTS    is (op=0xBB) {
    # TODO: get the correct stack pointer
    PC = *ssp;
    ssp = ssp + 4;

    goto [PC];
}
:EXTS   is (op=0xBC | op=0xBD | op=0xBE) unimpl

# MOVA (Move Effective Address)
:MOVA EAs, EAd  is op=0b10111111; (ea_a=0 ... & EAs); EAd unimpl
:MOVA EAs, R0   is op=0b10111111 & R0; (ea_a=1 ... & EAs) unimpl

:LINK   is (op=0xD0 | op=0xD1 | op=0xD2) unimpl
:UNLK   is (op=0xD3) unimpl
:BFEXT  is (op=0xD4) unimpl
:BFINS  is (op=0xD5) unimpl
:BFSCH  is (op=0xD6) unimpl
:BFMOV  is (op=0xD7) unimpl

:MOVTP  is (op=0xE0 | op=0xE1) unimpl
:MOVFP  is (op=0xE2 | op=0xE3) unimpl
:CGBN   is (op=0xE4 | op=0xE5 | op=0xE6 | op=0xE7) unimpl
:PGBN   is (op=0xE8 | op=0xE9) unimpl
:SWAP   is (op=0xEA | op=0xEB) unimpl
:TAS    is (op=0xEC) unimpl
:MUL    is (op=0xEE) unimpl
:DIV    is (op=0xEF) unimpl

:RESET  is op = 0xF0 unimpl
:RTE    is op = 0xF1 {
    sr = *ssp;
    ssp = ssp + 4;

    PC = *ssp;
    ssp  = ssp + 4;

    goto [PC];
}

# TRAPA (Trap Always)
:TRAPA imm4 is op=0b11110010; imm4 unimpl

:TRAP   is op = 0xF3 unimpl
:RTR    is op = 0xF4 unimpl
:SLEEP  is op = 0xF5 unimpl
# F6
# F7
:ANDC   is op = 0xF8 unimpl
:ORC EAs, CR    is op = 0b11111001; CR; EAs unimpl
:XORC   is op = 0xFA unimpl
:LDC <EAs>, CR    is op = 0b11111011; CR; EAs unimpl
:STC CR, <EAd>    is op = 0b11111100; CR; EAd unimpl
:ICBN   is op = 0xFD unimpl
:DCBN   is op = 0xFE unimpl
:NOP    is op = 0xFF {}
